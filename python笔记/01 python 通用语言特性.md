# 一、通用语言特性

## 1 变量与数据类型

- 整型
- 浮点型

- 字符串
- 布尔
- `None`

### 1.1 数值运算

- 加法
- 减法
- 乘法
- 除法
- 取余数`10%3`

- 次方`2**3`
- 整除`9//2`

### 1.2 比较运算

比较运算的运算符可以是大于（`>`），小于（`<`），大于等于（`>=`），小于等于（`<=`），等于（`==`），不等于（`!=`）。其写法与数学中的比较运算很相似，但不同的是「等于」和「不等于」，尤其注意「等于」是用两个等号 `==` 表示。

## 2 列表和字符串

### 2.1 列表（List）

列表的写法为 `[ 数据项1, 数据项2, ..., 数据项N ]`，方括号就代表列表，每个数据项放在方括号中并用逗号分隔。



#### **列表索引**

列表中的每个数据项都是有先后次序的，最前面的数据项的位置编号为 0，之后依次是 1 ，2 …… N，这个位置编号在编程中的术语叫做**索引**（Index）。注意 Python 中索引是从 0 开始计数的，0 即代表第一个位置。



#### **列表长度**

列表中数据项的个数，叫做**列表（的）长度**。想要获得列表的长度可以使用 `len()` 



#### **向列表添加数据**

**向列表的末尾添加数据**可以用 `.append()`这个东西





### 2.2 字符串（String）

#### **字符串索引**

从形式上我们不难看出，字符串中的字符也是有先后次序的。字符串是字符的有序序列，所以也具有索引。也可以根据索引取出其中某一个字符。

#### 不可变性

字符串不能像列表那样通过索引去改变数据项的值。因为字符串类型的值是**不可变的**（Immutable），因此不能在原地修改它其中的某个字符。



#### 字符串长度

字符串中字符的个数也就是**字符串的长度**（包括空格在内的所有空白符号）。

获取字符串长度的方式和列表一样，也是使用 `len()`：



## 3 分支和循环

### 3.1 分支

```python
if 条件 1:
    代码块 1
elif 条件 2:
    代码块 2
else
    代码块 3
```

`if` 可以配合 `elif` 和 `else` 一起使用。代码执行时，将会从第一个条件开始依次验证判断，若其中某个条件满足，则执行对应的代码块，此时后续条件将直接跳过不再验证。

一个 `if`-`elif`-`else` 组合中，`elif` 可出现任意次数，`else` 可出现 0 或 1 次。

### 3.2 循环

```py
while 条件:
    代码块
```

执行流程：从 `while 条件`这句出发，判断条件是否满足，若满足则执行代码块，然后再次回到 `while 条件`，判断条件是否满足……循环往复，直到条件不满足。

### 3.3 条件的与、或、取反

`if` 语句和 `while` 语句中的条件可以由多个语句组合表达。

| and  | or   | not  |
| ---- | ---- | ---- |
| 与   | 或   | 非   |

### 3.4 for 循环

通常用于执行遍历操作，写法为：

```python
for 项 in 序列:
    代码块
```

## 4 函数

函数的主要作用是抽象和代码复用。

Python 中函数的定义方法：

```python
def 函数名(参数1, 参数2, ...):
    代码块
```

返回值通过 `return` 语句传递到函数外部。

## 5 错误处理异常机制

#### try-except 语句捕获异常

异常的捕获使用 `try-except` 语句：

```python
try:
    代码块1
except:
    代码块2
```

执行流程是，从 `try` 下的 `代码块1` 开始执行，若其中有异常抛出，那么异常将会被捕获，直接跳转并执行 `except` 下的 `代码块2` 。若 `代码块1` 一切正常，并没有异常抛出，那么 `代码块2` 将不会被执行。

也就是说 `代码块1` 是我们想要正常运行的代码，而 `代码块2` 是当错误发生时用于处理错误的代码。

#### 捕获指定的异常

之前没有直接指定要捕获的异常类型，所以所有类型的异常都会被捕获。

我们也可以显式地指定要捕获的异常种类。方法是：

```python
try:
    代码块1
except 异常X as e:
    代码块2
```

和之前的区别在于，多出了 `异常X as e` 这一部分。`异常X` 是指定的要捕获的异常名，如 `IndexError`、`NameError`。`as e` 语句是将异常对象赋予变量 `e`，这样 `e` 就可以在 `代码块2` 中使用了

#### 捕获指定的多个异常

上面是指定并捕获一个异常，当然也可以在一个 `try` 语句下指定并捕获多个异常。有两种方式：

```python
try:
    代码块1
except (异常X, 异常Y, 异常Z) as e:
    代码块2
try:
    代码块1
except 异常X as e:
    代码块2
except 异常Y as e:
    代码块3
except 异常Z as e:
    代码块4
```

如上，第一种方式是将多个异常放在一个 `except` 下处理，第二种方式将多个异常分别放在不同的 `except` 下处理。无论用哪种方式，异常抛出时，Python 会根据异常类型去匹配对应的 `except` 语句，然后执行其中代码块，若异常类型未能匹配到，则异常会继续抛出。这两种方式的区别如下：

- 第一种方式适用于多种异常可用相同代码进行处理的情况。
- 第二种情况适用于每个异常需要用不同代码进行处理的情况。

#### try-except-finally 语句

在之前介绍的 `try-except` 语句之后，还可以紧跟 `finall` 语句，如下：

```python
try:
    代码块1
except 异常X as e:
    代码块2
finally:
    代码块3
```

它的执行流程是，

1. 首先执行 `代码块1`
2. 若发生异常则执行 `代码块2`，否则跳过 `代码块2`
3. 无论是否发生异常都执行 `代码块3`

也就是说在 `try-except` 执行流程的基础上，紧接着执行 `finally` 下的代码块，且 `finally` 下的代码必定会被执行。

`finally` 有什么用？举个例子，我们有时会在 `try` 下使用一些资源（比如文件、网络连接），而无论过程中是否有异常产生，我们在最后都应该释放（归还）掉这些资源，这时就可以将释放资源的代码放在 `finally` 语句下。



#### 常见的异常类型

下表中是 Python 常见的内置异常：

| 异常名            | 含义                           |
| :---------------- | :----------------------------- |
| Exception         | 大多数异常的基类               |
| SyntaxError       | 无效语法                       |
| NameError         | 名字（变量、函数、类等）不存在 |
| ValueError        | 不合适的值                     |
| IndexError        | 索引超过范围                   |
| ImportError       | 模块不存在                     |
| IOError           | I/O 相关错误                   |
| TypeError         | 不合适的类型                   |
| AttributeError    | 属性不存在                     |
| KeyError          | 字典的键值不存在               |
| ZeroDivisionError | 除法中被除数为 0               |

除此之外内置异常还有很多，待日后慢慢积累掌握。



#### raise 语句主动抛出异常

之前的示例中，异常是在程序遇到错误无法继续执行时，由解释器所抛出，我们也可以选择自己主动抛出异常。

主动抛出异常的方法是使用 `raise` 语句：

```python
raise ValueError()
```

也可以同时指明错误原因：

```python
raise ValueError("输入值不符合要求")
```

在函数内检验输入值的有效性，若输入有误则向外抛出异常，俄例如第 2 和第 3 行代码：

```python
def stage_of_life(age):
    if age < 0 or age > 150:
        raise ValueError("年龄的取值不符合实际，需要在 0 到 150 之间")
    
    if age <= 6:
        return '童年'
    elif 7 <= age <=17:
        return '少年'
    elif 18 <= age <= 40:
        return '青年'
    elif 41 <= age <= 65: 
        return '中年'
    else:
        return '老年'
```

这里检查 `age` 的范围是否在 0～150 之间，若不是则使用 `raise` 抛出 `ValueError` 异常，表示取值错误。



## 6 类

### 查看数据类型

Python 中内置有这么一个函数，通过它可以查看变量或值的数据类型，它就是 `type()`。像这样来使用：

```python
type(变量或值)
```

执行几个例子看看：

> \>>> type(100)
> <class ‘int’>

> \>>> type(3.14)
> <class ‘float’>

> \>>> type(‘words’)
> <class ‘str’>

> \>>> type(True)
> <class ‘bool’>

> \>>> type(None)
> <class ‘NoneType’>

> \>>> type([1, 2, 3])
> <class ‘list’>

执行的结果是 `` 形式，其中类型的含义是：

| 类型     | 含义       |
| :------- | :--------- |
| int      | 整数型     |
| float    | 浮点型     |
| str      | 字符串类型 |
| bool     | 布尔型     |
| NoneType | None 类型  |
| list     | 列表类型   |

上述的 `class`就是类



`class` 是指面向对象编程范式中的一个概念——**类**。Python 中的数据类型就是类，一个类对应一种数据类型。类的具体对象中可以保存若干数据，以及用于操作这些数据的若干函数。

我们来看一个例子：

我们常用的字符串类型，就是名为 `str` 的类。一个 `str` 中可以保存若干字符，并且针对这些字符提供了一系列的操作函数。

如 `'hello'` 就是一个 `str` 对象，我们可以把这个对象赋值给变量：



`str` 对象自带的 `find()` 函数，可用于获取字符的索引：

> \>>> words.find(‘e’)
> 1

`str` 对象自带的 `upper()` 函数，可用于获取英文字符的大写形式：

> \>>> words.upper()
> ‘HELLO’

除此 `str` 之外，前面列表中的那些数据类型也都是类。

### 类的定义

像 `str`、`int`、`list` 这样的类，是被预先定义好并且内置在 Python 中的。

当然，我们也可以自己来定义类。

类的定义方法是：

```python
class 类名:
    代码块
```

如：

```python
class A:
    pass
```

这里定义了一个非常简单的类，名为 `A`。`pass` 是占位符，表示什么都不做或什么都没有。



### 类的实例化

我们把类看作是自定义的数据类型，既然是类型，那么它只能用来表示数据的种类，不能直接用于保存数据。想要保存数据，就需要先创建一个属于这种类型的类似于容器的东西，这种容器就叫做**对象**（或称实例）。通过类产生对象的过程叫**实例化**。

打个比方，类就相当于图纸，对象就相当于按照图纸所生产出来的产品。图纸能决定产品的内部构造以及所具有的功能，但图纸不能替代产品被直接使用。类能决定对象能保存什么样的数据，以及能拥有什么样的函数，但类不直接用来保存数据。

定义好类以后，可以像这样实例化对象：

```python
变量 = 类名()
```

通过 `类名()` 这样类似函数调用的方式生成出对象，并将对象赋值给 `变量`。

如实例化之前的类 `A` 并将对象赋值为 `a`：

> \>>> class A:
> …   pass
> …
> \>>> a = A()

查看变量 `a` 的类型：

> \>>> type(a)
> <class ‘__main__.A’>

可以看到类型是 `__main__.A`，表示模块 `__main__` 下的 `A` 类。

可以看看 `a` 是什么：

> \>>> a
> <__main__.A object at 0x103d8e940>

`a` 是 `A` 的对象，位于内存的 `0x103d8e940` 地址。



### 对象属性

之前定义的 `A` 类是一个空的类，它的对象 `a` 并没有保存任何数据。

想要在对象中保存数据该怎么做呢？

可以像这样来定义类，实例化的时候就可以用参数的形式将数据传入，并保存在对象中：

```python
class 类名:
    def __init__(self, 数据1, 数据2, ...):
        self.数据1 = 数据1
        self.数据2 = 数据2
        ...
```

和之前相比类的内部多了一个函数 `__init__()`，作用如下：

- 接收要保存在对象中的数据
- **在实例化类的时候做一些初始化工作**。

我们通过实际例子来学习。之前介绍的类（数据类型）要么保存一个数据，要么保存多个数据，假如现在想要一个不多不少只保存两个数据的类，这就需要我们自己来定义了。如下：

```python
class Pair:
    def __init__(self, first, second):
        self.first = first
        self.second = second
```

我们将这个类命名为 `Pair`，即表示数据对。

它的 `__init__()` 函数有三个参数：

1. 第一个是 `self`，它是类中函数默认的第一个参数，表示对象自身。我们可以将数据赋值给 `self.数据名`，这样数据就保存在对象中了
2. `first` 是数据对的第一个值
3. `second` 是数据对的第二个值

实例化的时候像这样传入数据：

```python
pair = Pair(10, 20)
```

这个过程中会自动调用 `__init__()` 函数，并将 `10` 传给了 `first` 参数，将 `20` 传给了 `second` 参数，而 `__init__()` 的第一个参数 `self` 是不需要传值的，Python 会自动填充这个参数。

实例化之后我们可以通过 `pair = Pair(10, 20)` 来实例化 `Pair` 类，得到对象的变量 `pair`，使用 `pair.first`、`pair.second` 就可以获得对象中保存的数据了。

`first` 和 `second` 叫做 `Pair` 类的**对象属性**，一般也可以直接叫作属性。



### 对象方法

刚才在类中定义了对象属性，也可以在类中定义一些函数。这样的函数可直接由对象调用，例如我们之前学过的 `list.append()` 。

定义在类中，供对象调用的函数称为**对象方法**，一般也可以直接叫作方法。定义方式如下：

```python
class 类名:
    def 函数1(self, 参数1, 参数2):
        ...
```

定义对象方法时第一个参数默认使用 `self`，定义时必须有这个参数，但是调用时不必传递。之前介绍过的 `__init__()` 就是一个对象方法，不过是个特殊的对象方法。

我们在之前 `Pair` 类的基础上定义一个方法，功能是交换对象的 `first` 和 `second` 属性的值。来实现一下：

```python
class Pair:
    def __init__(self, first, second):
        self.first = first
        self.second = second
        
    def swap(self):
        self.first, self.second = self.second, self.first
```

这个方法被命名为 `swap`，无需传递参数，内部通过

```python
self.first, self.second = self.second, self.first
```

实现了 `self.first` 和 `self.second` 两个值的交换。

执行下看看：

> \>>> pair = Pair(10, 20)
> \>>> pair.first
> 10
> \>>> pair.second
> 20
>
> \>>> **pair.swap()**
>
> \>>> pair.first
> 20
> \>>> pair.second
> 10

## 7 模块和包

### 什么是模块？

存在两种运行 Python 代码的方式：

- 解释器的交互模式
- 直接运行 Python 代码文件。

在 Python 中，每一个 Python 文件就是一个**模块**。写程序时，可以将代码分散在不同的模块（文件）中，然后在一个模块里引用另一个模块的内容。



### 模块的导入

在一个模块中引用（导入）另一个模块，可以使用 `import` 语句:

```python
import 模块名
```

这里的模块名是除去 `.py` 后缀的文件名称。如，想要导入模块 `abc.py`，只需 `import abc`。

`import` 模块之后，就可以使用被导入模块中的名字（变量、函数类）。方式如下：

```python
模块名.变量
模块名.函数
模块名.类
```

#### 导入及使用模块示例

我们用个例子来试验下模块的导入和使用，在这个例子中，农民种下果树，然后等待果树结果收获。

在同一个目录下创建两个模块：

```undefined
tree_farmer  # 目录名
	|___tree.py # 文件名
	|___farmer.py # 文件名
```

第一个模块名为 `tree.py`，内容如下：

```python
import random

fruit_name = ''

def harvest():
    return [fruit_name] * random.randint(1, 9)
```

代码中各个变量和函数的功能如下：

- `fruit_name` 用来保存水果名称。将在函数 `harvest()` 中使用；
- `random.randint(1, 9)`，随机生成 1～9 中的一个数；
- `[fruit_name] * 数字`，该形式是将列表项重复若干遍。比如执行 `['X'] * 3` 将得到 `['X', 'X', 'X']`；
- 总体而言，`harvest()` 函数返回一个包含 1～9 个列表项的列表，其中每个项都是 `fruit_name` 的值。

第二个模块名为 `farmer.py`，内容如下：

```python
import tree

print('种下一棵果树。')
tree.fruit_name = 'apple'

print('等啊等，树长大了，可以收获了！')
fruits = tree.harvest()
print(fruits)
```

代码中，

- 第一行用 `import tree` 将 `tree.py` 模块导入进来（使用 `import` 导入时不需要写 `.py` 后缀）；
- 导入 `tree` 模块后，就可以使用其中的变量和函数了。将 `tree.fruit_name` 设置为 apple，调用 `tree.harvest()` 来收获 apple。

#### 标准库模块的导入

 `import random`：`random` 并不是我们所定义的模块， 是标准库中的一个模块。标准库是由 Python 官方开发的代码库，和解释器一起打包分发，其中包含非常多实用的模块，在使用时直接 `import` 进来即可。

------



### 执行模块时传入参数

刚才我们用这种方式来执行模块：

```sh
python3 模块文件名
```

其实我们还可以进一步将参数传递到模块中去，像这样：

```sh
python3 模块文件名 参数1 ...参数n
```

参数传递到模块中以后，我们可以通过 `sys` 模块来取出这些参数，参数放在 `sys.argv` 列表中：

```python
import sys

模块文件名 = sys.argv[0]
参数1     = sys.argv[1]
参数N     = sys.argv[N]
```

首先需要导入 `sys` 模块，这是个标准库中的模块。`sys.argv` 是个列表，执行模块时被传递进来的参数保存在其中，它的列表项分别为：

- `sys.argv[0]` 保存当前被执行模块的文件名
- `sys.argv[1]` 保存第 1 个参数
- `sys.argv[2]` 保存第 2 个参数
- 依次类推



修改 `farmer.py` 的代码，内容如下：

```python
import sys  # 新增
import tree

print('种下一棵果树。')
tree.fruit_name = sys.argv[1]   # 将 'apple' 改为 参数 sys.argv[1]

print('等啊等，树长大了，可以收获了！')
fruits = tree.harvest()
print(fruits)
```

以「banana」为例执行下看看：

> ➜ ~ python3 farmer.py banana
> 种下一棵果树。
> 等啊等，树长大了，可以收获了！
> [‘banana’, ‘banana’, ‘banana’]

在这个例子中 `sys.argv` 的值是：

- `sys.argv[0]`： farmer.py
- `sys.argv[1]`： banana

------



### 什么是包？

之前我们将定义的两个模块放在同一目录下，然后通过 `import` 语句来相互引用，这是一种扁平的模块组织结构，当模块数量很大的时候就很不灵活了，也难以维护。

Python 中可以用文件树这样的树形结构来组织模块，这种组织形式下的模块集合称为**包**（Package）。

比如包的结构可以是这样的：

```
包/
├── __init__.py
├── 模块1.py
├── 模块2.py
├── 子包1/
    ├── __init__.py
    ├── 模块3.py
    └── 模块4.py
└── 子包2/
    ├── __init__.py
    ├── 模块5.py
    └── 孙子包1/
        ├── __init__.py
        └── 模块6.py
```

这是个很明显的层级结构——包里面包含子包、子包包含孙子包…… 单独将子包或孙子包拿出来，它们也是包。

包的存在形式是目录，模块的存在形式是目录下的文件。所以我们可以很容易地构造出这样一个包，只要在文件系统中创建相应的目录和文件即可。

需要注意的是，每个层级的包下都需要有一个 `__init__.py` 模块。这是因为只有当目录中存在 `__init__.py` 时，Python 才会把这个目录当作包。



### 包的导入

导入包中模块的方法是：

```python
import 包.子包.模块
```

从最顶层的包开始依次向下引用子包，直至目标模块。

如，从上面示例的包结构中，

导入 `模块1.py`，使用：

```python
import 包.模块1
```

导入 `模块3.py`，使用：

```python
import 包.子包1.模块3
```

导入 `模块6.py`，使用：

```python
import 包.子包2.孙子包1.模块6
```



### 为什么需要模块和包？

模块的存在是为了更好的组织代码。将不同功能的代码分散在不同模块中，**清晰地划分出各个模块的职责，有利于使用和维护代码，同时也可避免模块中的内容过长**。

包的存在是为了更好的组织模块。与模块同理，包在更高的抽象层次上组织着代码。