# 什么是文件系统

⽂件系统是操作系统中负责管理持久数据的⼦系统，负责把⽤户的⽂件存到磁盘硬件中，即使计算机断电了，磁盘⾥的数据并不会丢失，所以可以持久化的保存⽂件。

Linux 最经典的⼀句话是：「⼀切皆⽂件」，不仅普通的⽂件和⽬录，就连块设备、管道、socket 等，也
都是统⼀交给⽂件系统管理的。

Linux ⽂件系统会为每个⽂件分配两个数据结构：==索引节点（index node）和⽬录项（directory entry）==，它们主要⽤来**记录文件的元信息和目录层次结构**。

- 索引节点，也就是 inode，⽤来记录⽂件的元信息，⽐如 inode 编号、⽂件⼤⼩、访问权限、创建时
  间、修改时间、数据在磁盘的位置等等。索引节点是⽂件的唯⼀标识，它们之间⼀⼀对应，也同样都
  会被存储在硬盘中，所以索引节点同样占⽤磁盘空间。

- ⽬录项，也就是 dentry，⽤来记录⽂件的名字、索引节点指针以及与其他⽬录项的层级关联关系。**多**
  **个⽬录项关联起来，就会形成⽬录结构，但它与索引节点不同的是，⽬录项是由内核维护的⼀个数据**
  **结构，不存放于磁盘，⽽是缓存在内存**。

由于索引节点唯⼀标识⼀个⽂件，⽽⽬录项记录着⽂件的名，所以⽬录项和索引节点的关系是多对⼀，也
就是说，⼀个⽂件可以有多个别字。⽐如，硬链接的实现就是多个⽬录项中的索引节点指向同⼀个⽂件。

注意，**⽬录也是⽂件，也是⽤索引节点唯⼀标识，和普通⽂件不同的是，普通⽂件在磁盘⾥⾯保存的是⽂**
**件数据，⽽⽬录⽂件在磁盘⾥⾯保存⼦⽬录或⽂件**。

## ⽬录项和⽬录是⼀个东⻄吗？

虽然名字很相近，但是它们不是⼀个东⻄，⽬录是个⽂件，持久化存储在磁盘，⽽⽬录项是内核⼀个数据
结构，缓存在内存。

如果查询⽬录频繁从磁盘读，效率会很低，所以内核会把已经读过的⽬录⽤⽬录项这个数据结构缓存在内
存，下次再次读到相同的⽬录时，只需从内存读就可以，⼤⼤提⾼了⽂件系统的效率。

## 那⽂件数据是如何存储在磁盘的呢？

磁盘读写的最⼩单位是扇区，扇区的⼤⼩只有==512B==⼤⼩，很明显，如果每次读写都以这么⼩为单位，
那这读写的效率会⾮常低。

所以，⽂件系统把多个扇区组成了⼀个**逻辑块**，每次读写的最⼩单位就是**逻辑块（数据块**），Linux 中的逻
辑块⼤⼩为 4KB ，也就是⼀次性读写 8 个扇区，这将⼤⼤提⾼了磁盘的读写的效率。

以上就是索引节点、⽬录项以及⽂件数据的关系，下⾯这个图就很好的展示了它们之间的关系：

<img src="https://gitee.com/ma-yunfei/picture/raw/master/20210914110833.png" alt="image-20210914110832762" style="zoom:67%;" />

索引节点是存储在硬盘上的数据，那么为了加速⽂件的访问，通常会把索引节点加载到内存中。

另外，磁盘进⾏格式化的时候，会被分成三个存储区域，分别是超级块、索引节点区和数据块区。

- 超级块，⽤来存储⽂件系统的详细信息，⽐如块个数、块⼤⼩、空闲块等等。
- 索引节点区，⽤来存储索引节点；
- 数据块区，⽤来存储⽂件或⽬录数据；

我们不可能把超级块和索引节点区全部加载到内存，这样内存肯定撑不住，所以**只有当需要使⽤的时候**，才将其加载进内存，它们加载进内存的时机是不同的：

- 超级块：当⽂件系统挂载时进⼊内存；
- 索引节点区：当⽂件被访问时进⼊内存；

# 虚拟⽂件系统

⽂件系统的种类众多，⽽操作系统希望对⽤户提供⼀个统⼀的接⼝，于是在⽤户层与⽂件系统层引⼊了中
间层，这个中间层就称为**虚拟⽂件系统（Virtual File System，VFS）**。

**VFS 定义了⼀组所有⽂件系统都⽀持的数据结构和标准接⼝，这样上层只需要了解 VFS 提供的统⼀接⼝，不需要了解⽂件系统的⼯作原理。**

在`Linux`⽂件系统中，⽤户空间、系统调⽤、虚拟机⽂件系统、缓存、⽂件系统以及存储之间的关系如下图：

<img src="https://gitee.com/ma-yunfei/picture/raw/master/20210914111255.png" alt="image-20210914111254784" style="zoom: 50%;" />

Linux ⽀持的⽂件系统也不少，根据存储位置的不同，可以把⽂件系统分为三类：

- **磁盘的⽂件系统**，它是直接把数据存储在磁盘中，⽐如 Ext 2/3/4、XFS 等都是这类⽂件系统。
- **内存的⽂件系统**，这类⽂件系统的数据不是存储在硬盘的，⽽是占⽤内存空间，我们经常⽤到的 
  /proc  和 /sys  ⽂件系统都属于这⼀类，读写这类⽂件，实际上是读写内核中相关的数据。
- **⽹络的⽂件系统**，⽤来访问其他计算机主机数据的⽂件系统，⽐如 NFS、SMB 等等。

⽂件系统⾸先要先挂载到某个⽬录才可以正常使⽤，⽐如 Linux 系统在启动时，会把⽂件系统挂载到根⽬
录。

# 文件的使用

我们从⽤户⻆度来看⽂件的话，就是我们要怎么使⽤⽂件？⾸先，我们得通过系统调⽤来打开⼀个⽂件。

<img src="https://gitee.com/ma-yunfei/picture/raw/master/20210914111548.png" alt="image-20210914111548520" style="zoom:50%;" />

```c
fd = open(name, flag); # 打开⽂件
...
write(fd,...);         # 写数据
...
close(fd);             # 关闭⽂件
```

上⾯简单的代码是读取⼀个⽂件的过程：

- ⾸先⽤ open 系统调⽤打开⽂件，open 的参数中包含⽂件的路径名和⽂件名。
- 使⽤ write 写数据，其中 write 使⽤ open 所返回的⽂件描述符，并不使⽤⽂件名作为参数。
- 使⽤完⽂件后，要⽤ close 系统调⽤关闭⽂件，避免资源的泄露。

我们打开了⼀个⽂件后，操作系统会跟踪进程打开的所有⽂件。所谓的跟踪呢，**就是操作系统为每个进程**
**维护⼀个打开⽂件表，⽂件表⾥的每⼀项代表「⽂件描述符」，所以说⽂件描述符是打开⽂件的标识**。

操作系统在打开⽂件表中维护着==打开⽂件的状态和信息==：

- ⽂件指针：**系统跟踪上次读写位置作为当前⽂件位置指针**，这种指针对打开⽂件的某个进程来说是唯
  ⼀的；
- ⽂件打开计数器：**⽂件关闭时，操作系统必须重⽤其打开⽂件表条⽬，否则表内空间不够⽤**。因为多
  个进程可能打开同⼀个⽂件，所以系统在删除打开⽂件条⽬之前，必须等待最后⼀个进程关闭⽂件，
  该计数器跟踪打开和关闭的数量，当该计数为 0 时，系统关闭⽂件，删除该条⽬；
- ⽂件磁盘位置：**绝⼤多数⽂件操作都要求系统修改⽂件数据，该信息保存在内存中，以免每个操作都**
  **从磁盘中读取；**
- 访问权限：每个进程打开⽂件都需要有⼀个访问模式（创建、只读、读写、添加等），该信息保存在
  进程的打开⽂件表中，以便操作系统能允许或拒绝之后的 I/O 请求；

在⽤户视⻆⾥，⽂件就是⼀个持久化的数据结构，但操作系统并不会关⼼你想存在磁盘上的任何的数据结
构，操作系统的视⻆是如何把⽂件数据和磁盘块对应起来。

所以，**⽤户和操作系统对⽂件的读写操作是有差异的**：

- ⽤户习惯以字节的⽅式读写⽂件，
- 操作系统则是以数据块来读写⽂件，那屏蔽掉这种差异的⼯作就是⽂件系统了，⽂件系统的基本操作单位是数据块。

读⽂件和写⽂件的过程：

- 当⽤户进程从⽂件读取 1 个字节⼤⼩的数据时，⽂件系统则需要获取字节所在的数据块，再返回数据
  块对应的⽤户进程所需的数据部分。
- 当⽤户进程把 1 个字节⼤⼩的数据写进⽂件时，⽂件系统则找到需要写⼊数据的数据块的位置，然后
  修改数据块中对应的部分，最后再把数据块写回磁盘。

# ⽂件的存储

⽂件的数据是要存储在硬盘上⾯的，数据在磁盘上的存放⽅式，就像程序在内存中存放的⽅式那样，有以下两种：

- 连续空间存放⽅式
- ⾮连续空间存放⽅式

其中，⾮连续空间存放⽅式⼜可以分为「**链表⽅式**」和「**索引⽅式**」。不同的存储⽅式，有各⾃的特点，重点是要分析它们的存储效率和读写性能。

## 连续空间存放⽅式

连续空间存放⽅式顾名思义，⽂件存放在磁盘「连续的」物理空间中。这种模式下，⽂件的数据都是紧密
相连，读写效率很⾼，因为⼀次磁盘寻道就可以读出整个⽂件。

使⽤连续存放的⽅式有⼀个前提，必须先知道⼀个⽂件的⼤⼩，这样⽂件系统才会根据⽂件的⼤⼩在磁盘
上找到⼀块连续的空间分配给⽂件。

所以，⽂件头⾥需要指定「起始块的位置」和「⻓度」，有了这两个信息就可以很好的表示⽂件存放⽅式
是⼀块连续的磁盘空间。

<img src="https://gitee.com/ma-yunfei/picture/raw/master/20210914112406.png" alt="image-20210914112406066" style="zoom:50%;" />

连续空间存放的⽅式虽然读写效率⾼，但是有「**磁盘空间碎⽚**」和「**⽂件⻓度不易扩展**」的缺陷。

### 磁盘空间碎⽚

如下图，如果⽂件 B 被删除，磁盘上就留下⼀块空缺，这时，如果新来的⽂件⼩于其中的⼀个空缺，我们就可以将其放在相应空缺⾥。但如果该⽂件的⼤⼩⼤于所有的空缺，但却⼩于空缺⼤⼩之和，则虽然磁盘上有⾜够的空缺，但该⽂件还是不能存放。当然了，**我们可以通过将现有⽂件进⾏挪动来腾出空间以容纳新的⽂件，但是这个在磁盘挪动⽂件是⾮常耗时，所以这种⽅式不太现实**。

<img src="https://gitee.com/ma-yunfei/picture/raw/master/20210914112523.png" alt="image-20210914112523425" style="zoom: 50%;" />

### ⽂件⻓度不易扩展

例如上图中的⽂件 A 要想扩⼤⼀下，需要更多的磁盘空间，唯⼀的办法就只能是挪动的⽅式，前⾯也说了，这种⽅式效率是⾮常低的



能解决上述问题的方式只有使⽤⾮连续空间存放⽅式。

## ⾮连续空间存放⽅式

⾮连续空间存放⽅式分为「链表⽅式」和「索引⽅式」。

### 链表方式

我们先来看看链表的⽅式。链表的⽅式存放是离散的，不⽤连续的，于是就==可以消除磁盘碎⽚，可⼤⼤提⾼磁盘空间的利⽤率==，同时⽂件的⻓度可以动态扩展。根据实现的⽅式的不同，链表可分为「隐式链表」和「显式链接」两种形式。

**隐式链表**：

⽂件要以「隐式链表」的⽅式存放的话，实现的⽅式是⽂件头要包含「第⼀块」和「最后⼀块」的位置，并且每个数据块⾥⾯留出⼀个指针空间，⽤来存放下⼀个数据块的位置，这样⼀个数据块连着⼀个数据块，从链头开是就可以顺着指针找到所有的数据块，所以存放的⽅式可以是不连续的。

隐式链表的存放⽅式的缺点：

- **⽆法直接访问数据块，只能通过指针顺序访问⽂件，以及数据块指针消耗了⼀定的存储空间。**
- 隐式链接分配的稳定性较差，==系统在运⾏过程中由于软件或者硬件错误导致链表中的指针丢失或损坏，会导致⽂件数据的丢失==。

**显示链表**：

如果取出每个磁盘块的指针，把它放在内存的⼀个表中，就可以解决上述隐式链表的两个不⾜。这种实现⽅式是「显式链接」，它指==把⽤于链接⽂件各数据块的指针，显式地存放在内存的⼀张链接表中，该表在整个磁盘仅设置⼀张，每个表项中存放链接指针，指向下⼀个数据块号==。

对于显式链接的⼯作⽅式，我们举个例⼦，⽂件 A 依次使⽤了磁盘块 4、7、2、10 和 12 ，⽂件 B 依次使
⽤了磁盘块 6、3、11 和 14 。利⽤下图中的表，可以从第 4 块开始，顺着链⾛到最后，找到⽂件 A 的全
部磁盘块。同样，从第 6 块开始，顺着链⾛到最后，也能够找出⽂件 B 的全部磁盘块。最后，这两个链都
以⼀个不属于有效磁盘编号的特殊标记（如 -1 ）结束。内存中的这样⼀个表格称为⽂件分配表（**File Allocation Table，FAT**）。

<img src="https://gitee.com/ma-yunfei/picture/raw/master/20210915113102.png" alt="image-20210915113102302" style="zoom:50%;" />

由于查找记录的过程是在内存中进⾏的，因⽽不仅显著地提⾼了检索速度，⽽且⼤⼤减少了访问磁盘的次数。但也正是整个表都存放在内存中的关系，它的主要的缺点是==不适⽤于⼤磁盘==。

⽐如，对于 200GB 的磁盘和 1KB ⼤⼩的块，这张表需要有 2 亿项，每⼀项对应于这 2 亿个磁盘块中的⼀
个块，每项如果需要 4 个字节，那这张表要占⽤ 800MB 内存，很显然 FAT ⽅案对于⼤磁盘⽽⾔不太合适。

### 索引

链表的⽅式解决了连续分配的磁盘碎⽚和⽂件动态扩展的问题，但是不能有效⽀持直接访问（FAT除外），索引的⽅式可以解决这个问题。

索引的实现是为每个⽂件创建⼀个「索引数据块」，⾥⾯存放的是指向⽂件数据块的指针列表。另外，⽂件头需要包含指向「索引数据块」的指针，这样就可以通过⽂件头知道索引数据块的位置，再通过索引数据块⾥的索引信息找到对应的数据块。创建⽂件时，索引块的所有指针都设为空。当⾸次写⼊第 i 块时，先从空闲空间中取得⼀个块，再将其地址写到索引块的第 i 个条⽬。

<img src="https://gitee.com/ma-yunfei/picture/raw/master/20210915113451.png" alt="image-20210915113451361" style="zoom: 50%;" />

索引的⽅式优点在于：

- ⽂件的创建、增⼤、缩⼩很⽅便；
- 不会有碎⽚的问题；
- ⽀持顺序读写和随机读写；

缺点：

- 由于索引数据也是存放在磁盘块的，如果⽂件很⼩，明明只需⼀块就可以存放的下，但还是需要额外分配
  ⼀块来存放索引数据，所以缺陷之⼀就是存储索引带来的开销。

如果⽂件很⼤，⼤到⼀个索引数据块放不下索引信息，这时⼜要如何处理⼤⽂件的存放呢？

### 组合

我们可以通过组合的⽅式，来处理⼤⽂件的存。先来看看==链表 + 索引==的组合，这种组合称为「链式索引块」，它的实现⽅式是在索引数据块留出⼀个存放下⼀个索引数据块的指针，于是当⼀个索引数据块的索引信息⽤完了，就可以通过指针的⽅式，找到下⼀个索引数据块的信息。那这种⽅式也会出现前⾯提到的链表⽅式的问题，万⼀某个指针损坏了，后⾯的数据也就会⽆法读取了。

<img src="https://gitee.com/ma-yunfei/picture/raw/master/20210915113629.png" alt="image-20210915113629104" style="zoom:50%;" />

还有另外⼀种组合⽅式是==索引 + 索引==的⽅式，这种组合称为「多级索引块」，实现⽅式是通过⼀个索引块
来存放多个索引数据块，⼀层套⼀层索引，像极了俄罗斯套娃是吧

<img src="https://gitee.com/ma-yunfei/picture/raw/master/20210915113746.png" alt="image-20210915113746582" style="zoom:50%;" />

# Unix ⽂件的实现⽅式

<img src="https://gitee.com/ma-yunfei/picture/raw/master/20210915113839.png" alt="image-20210915113839683" style="zoom:50%;" />

那早期 Unix ⽂件系统是组合了前⾯的⽂件存放⽅式的优点，如下图：

<img src="https://gitee.com/ma-yunfei/picture/raw/master/20210915113943.png" alt="image-20210915113943182" style="zoom:50%;" />

它是根据⽂件的⼤⼩，存放的⽅式会有所变化：

- 如果存放⽂件所需的数据块⼩于 10 块，则采⽤直接查找的⽅式；
- 如果存放⽂件所需的数据块超过 10 块，则采⽤⼀级间接索引⽅式；
- 如果前⾯两种⽅式都不够存放⼤⽂件，则采⽤⼆级间接索引⽅式；
- 如果⼆级间接索引也不够存放⼤⽂件，这采⽤三级间接索引⽅式；

那么，⽂件头（Inode）就需要包含 13 个指针：

- 10 个指向数据块的指针；
- 第 11 个指向索引块的指针；
- 第 12 个指向⼆级索引块的指针；
- 第 13 个指向三级索引块的指针；

所以，这种⽅式能很灵活地⽀持⼩⽂件和⼤⽂件的存放：对于⼩⽂件使⽤直接查找的⽅式可减少索引数据块的开销；
对于⼤⽂件则以多级索引的⽅式来⽀持，所以⼤⽂件在访问数据块时需要⼤量查询；这个⽅案就⽤在了 Linux Ext 2/3 ⽂件系统⾥，虽然解决⼤⽂件的存储，但是对于⼤⽂件的访问，需要⼤量的查询，效率⽐较低。为了解决这个问题，Ext 4 做了⼀定的改变，具体怎么解决的，本⽂就不展开了。
