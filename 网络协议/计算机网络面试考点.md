# 计算机网络面试考点

# 应用层 http

## HTTP协议

- HTTP连接使用请求——响应的方式

- HTTP使用TCP而不是UDP的原因：一个网页必须传送很多数据，而TCP协议提供传输控制，有序组织数据，和数据错误纠正。

## HTTP1.0 HTTP1.1 HTTP2.0

特点：

| HTTP 1.0                  | HTTP 1.1                                                     | HTTP 2.0                                                     |
| ------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 浏览器—服务器**短暂连接** | 默认采用持久连接（带流水线的持久连接）                       | 提高web性能，减少网络延迟                                    |
|                           | 一个TCP连接可以发送多个HTTP请求和响应                        | 多路复用：客户端在同一时间内，针对同一个域名的请求没有限制 ；很容易实现多流并行，而不依赖所个TCP连接 |
|                           | 可以不等待上一个请求结束就发送下一个请求                     | **二进制分帧**：应用层与传输层之间增加二进制分帧层，改进传输的性能，单连接多资源 |
|                           | Request和response存在一个connection头，client和server通信时长连接是怎样处理的 | 首部压缩                                                     |
|                           |                                                              | 服务端推送：服务器可对客户端的一个请求发送多个响应（直接把客户端需要的都传送出去、可以缓存）。 |

> client和server都是默认对方支持长链接的， 如果client使用http1.1协议，但又不希望使用长链接，则需要在header中指明connection的值为close；如果server方也不想支持长链接，则在response中也需要明确说明connection的值为close。不论request还是response的header中包含了值为close的connection，都表明当前正在使用的tcp链接在当天请求处理完毕后会被断掉。以后client再进行新的请求时就必须创建新的tcp链接了。

 影响：

| HTTP 1.0                                                  | HTTP 1.1                      | HTTP 2.0                  |
| --------------------------------------------------------- | ----------------------------- | ------------------------- |
| 每次建立关闭连接消耗性能                                  | 默认采用持久连接              | 提高web性能，减少网络延迟 |
| 连接无法复用：每次连接请求都要经历三次握手和慢启动        | 以管道的方式同时发送多个请求  |                           |
| **head of line blocking**：带宽无法充分利用，阻塞后续请求 | 支持host请求字段（虚拟站点）  |                           |
|                                                           | 身份认证、状态管理、cache缓存 |                           |
|                                                           | 支持断点续传                  |                           |

## 移动app

前提：

- 客户端连接请求集中在一段时间内
- 移动app请求分散，时间跨度大

所以移动端一般使用长连接或者伪长连接：

方案（1）：基于TCP的长连接

- 基于TCP协议建立属于自己的长连接通道，例如google protobuf

方案（2）：HTTP LONG-POLLING

- 客户端初始状态会发送一个polling轮询请求给服务器，服务器不会马上返回业务数据，而是等待有新业务数据产生时再返回，此时连接会一直保存
- 稳定性不好：需要做一些数据的可靠性保证，比如重发和ack机制
- 会被中间代理商cache，需要做业务的过期机制

方案（3）：HTTP STREAMING

方案（4）：WEB SOCKET

## HTTPS

- 加密协议
- 使用TLS协议对HTTP传输数据加密：非对称加密、对称加密以及HASH算法

运行过程：

客户端与服务端进行第一次握手，确认双方传输数据的密码信息

1. 浏览器将自己的一套加密规则发送给服务器

2. 网站选出一组加密算法和HASH算法，并将身份信息以证书的形式发送给网站（证书包含：网址、加密公钥、证书颁发机构）

3. 得到证书，浏览器需要做如下事情：

   1. 验证证书的合法性

   > 颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等; 如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。



> b) 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。
>  c) 使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。
>
> 4.网站接收浏览器发来的数据之后要做以下的操作：
>  a) 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。
>  b) 使用密码加密一段握手消息，发送给浏览器。
>
> 5.浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。
>
> 这里浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据。其中非对称加密算法用于在握手过程中加密生成的密码，对称加密算法用于对真正传输的数据进行加密，而HASH算法用于验证数据的完整性。由于浏览器生成的密码是整个数据加密的关键，因此在传输的时候使用了非对称加密算法对其加密。非对称加密算法会生成公钥和私钥，公钥只能用于加密数据，因此可以随意传输，而网站的私钥用于对数据进行解密，所以网站都会非常小心的保管自己的私钥，防止泄漏。
>
> TLS握手过程中如果有任何错误，都会使加密连接断开，从而阻止了隐私信息的传输。正是由于HTTPS非常的安全，攻击者无法从中找到下手的地方，于是更多的是采用了假证书的手法来欺骗客户端，从而获取明文的信息。默认HTTP的端口号为80，HTTPS的端口号为443。
>
> 
>
> 作者：一个人在路上走下去
> 链接：https://www.jianshu.com/p/52d86558ca57
> 来源：简书
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



## 常用的请求方式

| 请求方式 | 说明                             |
| -------- | -------------------------------- |
| GET      | 附带关键字获取资源，携带的信息少 |
| POST     | 携带的信息大，附加新的数据       |
| PUT      | 幂等性，请求服务器存储一个资源   |
| HEAD     | 获取响应信息报头                 |
| DELETE   | 删除资源                         |

# 传输层

传输层的分用和复用

差错检测

### UDP

UDP主要特点：

- 不安全：采用应用层控制安全

- 面向报文
- 无拥塞控制

- 首部开销小

#### UDP校验

在发送端：

- 填上伪首部
- UDP首部校验字段0填充
- 全0填充数据部分（udp数据报看成许多4b的字段连接）
- 伪首部 + 首部 + 数据 采用二进制反码求和
- 把和求反码，填入校验字段
- 去掉伪首部，发送

在接收端：

- 填上伪首部
- 伪首部+首部+数据反码求和
- 结果全为1则无差错，否则丢弃数据报/或者交给应用层，附上差错警告

![image-20200903154530178](/Users/xuepipi/Library/Application Support/typora-user-images/image-20200903154530178.png)

### TCP协议

- 面向连接的协议
- 只能点对点，一对一
- Tcp 可靠有序，不丢不重
- TCP全双工通信，两个人可以同时发送数据，也可以同时接受数据。
  - 发送缓存：准备发送的数据 & 已经发送但未收到确认的数据
  - 接受缓存：按序到达没有被应用程序读取的数据 & 不按序到达的数据
- 面向字节流： tcp把数据看成一连串无结构的字节流

#### TCP报文段的首部格式

![image-20200903160057197](/Users/xuepipi/Library/Application Support/typora-user-images/image-20200903160057197.png)

| 术语              | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| 序号字段          | 报文中的第一个字节的序号                                     |
| 确认号            | 期望收到对方报文段第一个字节的序号，若序号为n则说明序号n-1为止所有数据均已正确收到 |
| 数据偏移          | 数据起始处距离整个报文段的起始处有多远，**首部的长度**，4B为单位 |
| URG（发送方优先） | URG = 1表明此报文段有紧急数据，应该尽快传送，不用在缓存排队  |
| PSH（接收方优先） | PSH=1接收方尽快向上层交付，不用等到缓存填满时交付            |
| 紧急指针          | 指出紧急数据所在的位置                                       |
| ACK               | 连接建立后，所有传送的报文都应该将ACK置为1                   |
| RST               | RST=1，连接出现严重差错，必须释放连接重新传输                |
| SYN               | SYN=1，表明连接请求/连接报文                                 |
| FIN               | FIN=1，数据发完，释放连接                                    |
| 窗口字段          | 允许对方发送的数据量，限制对方发送的缓存                     |
| 检验和            | 检验首部和数据部分，加上12B伪首部，第四个字段为6             |
| 选项              | 最大报文段长度MSS、窗口扩大字段、时间戳字段                  |

#### TCP连接管理

![image-20200903162720011](/Users/xuepipi/Library/Application Support/typora-user-images/image-20200903162720011.png)

##### 建立连接

![image-20200903162848617](/Users/xuepipi/Library/Application Support/typora-user-images/image-20200903162848617.png)

（1）客户端发送连接请求报文段，无应用层数据。SYN=1,seq = x （序号位随机产生的） 不需要确认序号，确认序号是没有意义的，所以不需要ACK

（2）服务器为该TCP连接**分配缓存和变量**，并向客户端返回确认报文段

（3）客户端为该TCP连接分配缓存和变量，并向服务器返回和确认，可携带数据

SYN的洪泛攻击：攻击者大量连续发送(1)，一直消耗资源，直至宕机

**为什么要三次握手？**

因为网络是不稳定的：

（1）A，B通信，如果A->B可以通信，B应答A，但B无法知道自己是否能将消息传送至A，建立的连接不可靠

（2）建立连接之前A发送了一段数据，AB建立连接不久断开连接，那个请求又到B，此时就会使B永远在等A的数据

（3）序号问题

（4）分配缓存和变量

##### 连接释放

![image-20200903165817961](/Users/xuepipi/Library/Application Support/typora-user-images/image-20200903165817961.png)

（1）客户端发送连接释放报文段

（2）服务端回复确认报文段，客户端处于半关闭状态

（3）服务端发完数据，发出释放报文段

（4）客户端回复确认报文段，再等待2MSL（最长报文段寿命），看看是否重传，连接彻底关闭

第四次的作用：避免客户端一直等待服务端传输完毕的请求

等待一段时间作用：如果客户端直接关闭，第四次传输有问题，服务端将不停完成(3)，等待一段时间如果等到服务端的下一次请求，重新发（4）

#### TCP可靠传输

四种机制：校验、序号、确认、重传

校验：添加伪首部，与UDP类似

序号：有序的提交应用层

确认：**默认使用累计确认**。接收方返回确认报文段，发送方收到后，在缓存中删除发送报文段；若发生丢失，也仅确认已收到的连续报文段

![image-20200903172741527](/Users/xuepipi/Library/Application Support/typora-user-images/image-20200903172741527.png)

重传：TCP在规定时间未收到确认就要重传已发送的报文段。



**超时重传**：重传时间）TCP采用自适应算法，动态改变重传时间RTTS（加权平均往返时间)

**快重传**：冗余ACK

![image-20200904150701546](/Users/xuepipi/Library/Application Support/typora-user-images/image-20200904150701546.png)



## TCP拥塞控制

拥塞控制的目的：最大限度利用网络瓶颈链路的带宽

类比于水管：

水管中的水量 = 水管的粗细 * 水管的长度

链路上可容纳的最大数据包的数量 = 链路带宽 * 往返延迟

为了保证水管不会爆，TCP维护了一个拥塞窗口cwnd，用来估计一段时间内链路的水量

### 如何知道网络的最大传输效率？

只要网络中未出现拥塞，拥塞窗口值可以继续增大，可以放更多的数据；如果出现拥塞，拥塞窗口应该减小，以减小注入到网络中的数据

## 常见的拥塞控制的算法

### **Reno**

四个阶段：慢启动 、拥塞避免、快重传、快恢复

![image-20200903142429374](/Users/xuepipi/Library/Application Support/typora-user-images/image-20200903142429374.png)



传输轮次：发送一批报文段并收到他们确认的时间 (RTT往返时延)

慢启动：不要一开始发送大量数据（只注入一个报文段），先探测一下网络的拥塞程度，由小到大的增加拥塞窗口大小。一轮中每收到一个ack，就将拥塞窗口加1，每轮加一倍

拥塞避免：当窗口达到慢启动的阈值或出现丢包，则进入拥塞避免状态。窗口每轮次加一，呈线性增长；当出现网络拥塞 , 将慢启动阈值设置为拥塞值的一半，从头开始

![image-20200903143712389](/Users/xuepipi/Library/Application Support/typora-user-images/image-20200903143712389.png)

快重传：当出现拥塞的时候，发送方收到三个相同的ack，赶快重传，这样可以在超时计时器到期之前重传

快恢复：不用降至1，降至新的阈值ssthresh



# 网络层 IP

# 数据链路层 MAC

# 常见协议

## NAT协议

专用网连接到因特网的路由器上安装nat软件，安装这个软件的路由器称为nat路由，至少有一个有效的外部全球ip地址。

nat表，外网ip端口对应内网的私有ip和端口

## DHCP协议

应用层的协议，对网络层影响较大，动态分配地址

# 路由协议

## ARP协议

数据链路层找到对应的Mac地址，并存储映射

## 动态路由协议

存在自己的路由算法，能够自动适应网络拓扑的变化，适用于具有一定数量三层设备的网络，占资源

### RIP

RIP是Routing Information Protocol（路由信息协议）

- 协议简单，每隔30秒广播一次路由表，维护相邻路由器的位置关系
- 适用于小型网络，最大跳数为16跳,16跳以及超过16跳的网络则认为目标网络不可达
- 基于距离矢量算法的协议，RIP的收敛速度较慢
- RIP使用UDP数据包更新路由信息。30s不可达，240s删除

### IGRP

内部网关路由协议（Interior Gateway Routing Protocol，IGRP）

- IGRP的收敛时间更长，但传输路由信息所需的带宽减少
- 原理与RIP类似
- Cisco IOS允许路由器管理员对IGRP的网络带宽、延时、可靠性和负载进行权重设置，以影响度量的计算。
- IGRP的收敛时间更长，但传输路由信息所需的带宽减少

### OSPF

开放式最短路径优先(Open Shortest Path First)：

- 存在区域的概念，每个区域的所有路由维护着一个相同链路状态的数据库(LSDB)
- 骨干区域和非骨干区域，必须存在骨干区域，非骨干与骨干区域相连接
- 利用链路状态的数据表，通过最短生成树算法计算得到路由表
- 收敛速度快

### ISIS

中间系统到中间系统(Intermediate system to intermediate system)：

- 区域概念
- 维护一个相同链路状态的数据库(LSDB)
- 通过最短生成树算法计算得到路由表

### BGP

- 可以将一个网络分成多个自治系统。自治系统间使用eBGP广播路由，自治系统内使用iBGP在自己的网络内广播路由。
- BGP必须依靠面向连接的TCP会话以提供连接状态

## 静态路由协议

静态路由配置方便，对系统要求低，适用于拓扑结构简单并且稳定的小型网络。

# ipv4 vs ipv6

- 32 bit -> 128bit，扩展路由寻址能力
- **报头格式的简化**
- **加强了对移动设备的支持**
- **身份验证和保密**