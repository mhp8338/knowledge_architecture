# 进程

# 线程

## 内核线程和用户线程

## 内核线程

多核心处理器：在一个处理器上集成多个运算核心从而提高计算能力。有多个并行计算的处理核心，每个核心对应一个内核线程。

内核线程：直接由操作系统内核支持的线程，**由内核完成线程切换**，**内核通过调度器对线程进行调度**，并负责将线程的任务映射到各个处理器上。

处理器：内核线程 =  1 : 1

现在的电脑一般是双核四线程、四核八线程，是采用**超线程技术**将一个物理处理核心模拟成两个逻辑处理核心，对应两个内核线程，所以在操作系统中看到的CPU数量是实际物理CPU数量的两倍，如你的电脑是双核四线程

## 用户线程

程序一般不直接使用内核线程，而是使用内核线程的一种高级接口——轻量级进程。每个用户线程都需要一个内核线程支持，只有先支持内核线程，才能有轻量级进程。

## 内核线程与用户线程的对应关系

用户线程与内核线程存在三种模型关系：

- 一对一模型
- 多对一模型
- 多对多模型

### 一对一模型

一个用户线程对应**唯一的**一个内核线程（反过来不一定成立）。

一个用户线程就唯一映射到一个物理CPU的内核线程，线程之间的并发是真正的并发。

优点：

- 一个线程因某种原因阻塞时其他线程的执行不受影响

缺点：

- 许多操作系统限制了内核线程的数量，即用户线程的数量也会收到限制
- 许多操作系统内核线程调度时，上下文切换开销较大，用户执行效率下降

![image](https://raw.githubusercontent.com/SurvivalBoy/imageGallery/master/JVM/one_on_one.png)

### 多对一模型

多个用户线程对应映射一个内核线程上，线程之间的切换由用户态代码进行，系统内核感受不到线程的实现方式。用户线程的建立、同步、销毁等都在用户态完成，不需要内核的介入

优点（相比于一对一模型）：

- 多对一模型的线程上下文切换速度快得多
- 对用户线程的数量几乎无限制

缺点：

- 如果一个用户线程阻塞，其他所有线程都将无法执行，因为此时内核线程也随之阻塞了
- 再多处理器系统上，处理器增加对多对一模型的线程性能不会增加，因为所有的用户线程都映射到一个处理器上

![image](https://raw.githubusercontent.com/SurvivalBoy/imageGallery/master/JVM/many_to_one.png)

### 多对多模型

将多个用户线程映射到多个内核线程上。由线程库负责在可用的可调度实体上调度线程，使得线程的上下文切换非常快，因为其避免了系统调用。

缺点： 增加了复杂性和优先级倒置的可能性，以及在用户态调度程序和内核调度程序之间没有广泛且高昂协调的次优调度。

优点：

- 一个用户线程的阻塞不会导致所有线程阻塞，因为此时还有别的内核线程被调度来执行
- 多对多模型用户线程的数量没有限制
- 在多处理器操作系统中，多对多模型的线程也能得到一定的性能提升，但提升幅度不如一对一高

![image](https://raw.githubusercontent.com/SurvivalBoy/imageGallery/master/JVM/many_to_many.png)

在现在流行的操作系统中，大都采用多对多的模型。

# 协程

协程是一种基于线程之上，但又比线程更加轻量级的存在。是由IT工作者自己写的程序来管理的轻量级线程，对内核线程来说具有不可见性。

一个线程可以拥有多个协程

