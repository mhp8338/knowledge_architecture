内存存储实现：电流

磁盘存储实现：磁效应



内存：只要指主内存（负责CPU中运行的程序指令和数据的内存）

磁盘：硬盘



程序要开始加载到内存中才能开始执行



# 磁盘缓存

把从磁盘读出的数据存储至内存空间中，接下来读取数据可以不通过硬盘，而直接通过内存读取

# 虚拟内存把磁盘作为部分内存来使用  

 虚拟内存是指把磁盘的一部分作为假想的内存来使用。 这**与磁盘缓存是假想的磁盘（ 实际上是内存） 相对**， 虚
拟内存是假想的内存（ 实际上是磁盘）。  

作用：借助虚拟内存， 在内存不足时也可以运行程序。 例如，在只剩下 5MB 内存空间的情况下也能运行 10MB 大小的程序  

实现方式：必须把实际内存（ 也可称为物理内存） 的内容， 和磁盘上的虚拟内存的内容进行部分置换（ swap）， 并同时运行程序  



虚拟内存的方法有分页式和分段式两种



 把运行的程序按照一定大小的页（ page）进行分割， 并以页为单位在内存和磁盘间进行置换。在分页式中， 我们把磁盘的内容读出到内存称为 Page In， 把内存的内容写入磁盘称为Page Out。    

一般情况下， Windows 计算机的页的大小是 4KB。 也就是说， 把大程序用 4KB 的页来进行切分， 并以页为单位放入磁盘（ 虚拟
内存）或内存中  。

使用虚拟内存时发生的 Page In 和 Page Out 往往伴随着低速的磁盘访问， 因此在这个过程中应用的运行会变得迟钝起来。



**解决内存不足的问题， 需要增加内存的容量， 或者尽量把运行的应用文件变小。**  

# 运行的应用程序变小

### 通过 DLL（ Dynamic Link Library）文件实现函数共有  

- 程序运行时可以动态加载 Library（ 函数和数据的集合） 的文件。
- 多个应用可以共有同一个 DLL 文件    

<img src="C:\Users\mhp\AppData\Roaming\Typora\typora-user-images\image-20200922141344597.png" alt="image-20200922141344597" style="zoom: 67%;" />

<img src="C:\Users\mhp\AppData\Roaming\Typora\typora-user-images\image-20200922141513397.png" alt="image-20200922141513397" style="zoom:67%;" />



**利用多个 DLL 文件， 其中一个原因就是可以节约内存。**

**而且 DLL 文件还有一个优点就是， 在不变更 EXE文件的情况下， 只通过升级 DLL 文件就可以更新。**  

### 通过调用 _stdcall 来减小程序文件的大小  

通过调用 _stdcallA（standard call 标准调用）来减小程序文件的方法， 是用 C 语言编写应用时可以利用的高级技巧。  

####  栈清理处理

把不需要的数据从接收和传递函数的参数时使用的内存上的栈区域中清理出去。  

# 5.5 磁盘的物理结构

划分的方式有扇区方式和可变长方式两种， 前者是指将磁盘划分为固定长度的空间， 后者则是指把磁盘划分为长度可变的空间  

扇区方式中， 把磁盘表面分成若干个同心圆的空间就是磁道， 把磁道按照固定大小（ 能存储的数据长度相同） 划分而成的空间就是扇区  

<img src="C:\Users\mhp\AppData\Roaming\Typora\typora-user-images\image-20200922144154309.png" alt="image-20200922144154309" style="zoom:67%;" />

Windows 在逻辑方面（ 软件方面） 对磁盘进行读写的单位是扇区整数倍**簇** 

1 簇可以是 512 字节（ 1 簇 = 1 扇区）、1KB（ 1 簇 = 2 扇区）、2KB、4KB、8KB、16KB、32KB（1簇 = 64扇区）  

不管是硬盘还是软盘， 不同的文件是不能存储在同一个簇中的，否则就会导致只有一方的文件不能被删除。 因此， 不管是多么小的文
件， 都会占用1簇的空间。  

如果减少簇的容量， 磁盘访问次数就会增加， 就会导致读写文件的时间变长。 由于在磁盘表面上， 表示扇区区分的领域是必要的， 因此， 如果簇的容量过小， 磁盘的整体容量也会减少。  