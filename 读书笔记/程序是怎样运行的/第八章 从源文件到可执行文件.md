源码 --->编译器 --->本地代码

# 8.1 计算机只能运行本地代码

作为计算机大脑的
Pentium 等 CPU， 也只能解释已经转换成本地代码的程序内容  

# 8.2 本地代码的内容

<img src="C:\Users\mhp\AppData\Roaming\Typora\typora-user-images\image-20200923104022913.png" alt="image-20200923104022913" style="zoom:67%;" />

# 8.3 编译器负责转换源代码

能够把 C 语言等高级编程语言编写的源代码转换成本地代码的程序称为编译器。每个编写源代码的编程语言都需要其专用的编译器。将 C 语言编写的源代码转换成本地代码的编译器称为 C 编译器。  

编译器首先读入代码的内容， 然后再把源代码转换成本地代码。
编译器中就好像有一个源代码同本地代码的对应表。 但实际上， 仅仅靠对应表是无法生成本地代码的。 读入的源代码还要经过语法解析、句法解析、 语义解析等， 才能生成本地代码。  

<img src="C:\Users\mhp\AppData\Roaming\Typora\typora-user-images\image-20200923104506683.png" alt="image-20200923104506683" style="zoom:67%;" />

# 8.4 仅靠编译是无法得到可执行文件的  

编译后生成的不是 EXE 文件， 而是扩展名为“.obj” 的 目标文件 A。Sample1.c 编译后， 就生成了 Sample1.obj 目标文件。 虽然目标文件的内容是本地代码， 但却无法直接运行。 那么这是为什么呢？ 原因就是当前程序还处于未完成状态。  

# 8.5 启动及库文件

# 8.6 DLL 文件及导入库

MessageBox() 的目标文件是存储在import32.lib 中的。 实际上， import32.lib 中仅仅存储着两个信息， 一是MessageBox() 在 user32.dll 这个 DLL 文件中， 另一个是存储着 DLL 文件的文件夹信息， MessageBox() 的目标文件的实体实际上并不存在。我们把类似于 import32.lib 这样的库文件称为导入库。  

DLL 文件是程序运行时动态结合的文件。  

<img src="C:\Users\mhp\AppData\Roaming\Typora\typora-user-images\image-20200923111542468.png" alt="image-20200923111542468" style="zoom:67%;" />

# 8.7 可执行文件运行时的必要条件

那就是 EXE 文件中给变量及函数分配了虚拟的内存地址。 在程序运行时， 虚拟的内存地址会转换成实际的
内存地址。 链接器会在 EXE 文件的开头， 追加转换内存地址所需的必要信息。 这个信息称为**再配置信息**。  

EXE 文件的再配置信息， 就成为了变量和函数的相对地址。 相对地址表示的是相对于基点地址的偏移量， 也就是相对距离。 实现相对
地址， 也是需要花费一番心思的。 在源代码中， 虽然变量及函数是在不同位置分散记述的， 但在链接后的 EXE 文件中， 变量及函数就会变成一个连续排列的组。 这样一来， 各变量的内存地址就可以用相对于变量组起始位置这一基点的偏移量来表示， 同样， 各函数的内存地址也可以用相对于函数组起始位置这一基点的偏移量来表示。 而各组基点的内存地址则是在程序运行时被分配的。  

<img src="C:\Users\mhp\AppData\Roaming\Typora\typora-user-images\image-20200923112037192.png" alt="image-20200923112037192" style="zoom:67%;" />

# 8.8 程序加载时会生成栈和堆

EXE 文件的内容分为再配置信息、 变量组和函数组， 这一点想必大家都清楚了吧。 不过， 当程序加载到内存后， 除此之外还会额外生
成两个组，那就是栈和堆。栈是用来存储函数内部临时使用的变量（ 局部变量 A）， 以及函数调用时所用的参数的内存区域。  堆是用来存储程序运行时的任意数据及对象的内存领域  

栈和堆需要的内存空间是在EXE 文件加载到内存后开始运行时得到分配的。 因而， 内存中的程序，就是由用于变量的内存空间、 用于函数的内存空间、 用于栈的内存空间、 用于堆的内存空间这 4 部分构成的。 当然， 在内存中， 加载Windows 等操作系统的内存空间又是另外一回事了。 

<img src="C:\Users\mhp\AppData\Roaming\Typora\typora-user-images\image-20200923112517418.png" alt="image-20200923112517418" style="zoom:67%;" />

在内存的使用方法上， 二者存在些许不同。 栈中
对数据进行存储和舍弃（ 清理处理） 的代码， 是由编译器自动生成的，
因此不需要程序员的参与。 使用栈的数据的内存空间， 每当函数被调
用时都会得到申请分配， 并在函数处理完毕后自动释放。 与此相对，
堆的内存空间， 则要根据程序员编写的程序， 来明确进行申请分配或
释放。  



根据编程语言的不同， 对堆用的内存空间进行申请分配和释放的
程序的编写方法也是多种多样的。 C 语言中是通过 malloc() 函数来进行
申请分配、 通过 free() 函数来释放的。 而 C++ 中则是通过 new 运算符
来申请分配、 通过 delete 运算符来释放的。 无论是 C 语言还是 C++，
如果没有在程序中明确释放堆的内存空间， 那么即使在处理完毕后，
该内存空间仍会一直残留。 这个现象称为 内存泄露（ memory leak）， 它
是令 C 语言及 C++ 的程序员们十分头疼的一个 bug（ 程序的错误）。 如
果内存泄露一直存在的话， 就有可能会造成内存不足而导致宕机。 这
就好比， 如果水龙头一直嘀嗒嘀嗒地漏水， 那么一晚上的时间水桶就
可能会装满并溢出  