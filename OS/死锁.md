# 死锁

死锁的一种产生场景：

```c
Producer(item){
	p(mutex);
	p(empty);
	...
	v(full);
	v(mutex);
}

Consumer(){
	p(mutex);
	p(full);
	...
	v(empty);
	v(mutex);
}
```

假设mutex = 1，`empty=0`(队列已满)

**P**:

``mutex : `1 -> 0`

empty: `0 -> -1` 阻塞

**V**:

mutex : `0 -> -1` 阻塞，此时无法释放`V(empty)`，**产生死锁，环路等待**

死锁：多个进程由于互相等待对方持有的资源，最终导致谁也无法执行的结果

影响：被阻塞的进程资源越来越多，计算机无法工作

# 死锁的成因

- 资源互斥使用，一旦占有，别人无法使用

- 进程占有了一些资源，又不释放，再申请其他资源
- 各自占有的资源和互相申请的资源形成环路等待

# 死锁的必要条件

- 互斥使用和不可抢占（资源的固有属性）
- 请求和保持（进程占有资源，去申请其他资源，被阻塞不释放资源）

- 循环与等待（在资源分配图中存在一个环路）

# 死锁处理方法

## 死锁预防

原理：破坏死锁的出现条件

### 方法示例

（1）在进程执行前，一次性申请所有需要的资源，不会出现占有资源再去申请其他资源的情况

缺点：

- 需要预知未来，编程困难
- 许多资源分配后很长时间后才使用，资源利用率低

（2）资源排序，资源申请必须按顺序申请

- 仍造成资源浪费

## 死锁避免

原理：检测每个资源请求，如果造成死锁就拒绝

### 银行家算法

找到一个安全状态，多进程按照该状态执行，不会产生死锁

<img src="https://gitee.com/ma-yunfei/picture/raw/master/20210727134514.png" alt="image-20210727134513985" style="zoom:50%;" />

安全序列的次序 `P1,P3,P2,P4,P0`

<img src="https://gitee.com/ma-yunfei/picture/raw/master/20210727134951.png" alt="image-20210727134951080" style="zoom:50%;" />

缺点：

- 每次运行都需要调用银行家算法，效率低下

## 死锁检测+恢复

原理：检测到死锁出现时，回滚进程

每次申请都执行银行家算法`O(mn^2)`，效率低。因此可以等发现问题之后再处理

- 定时检测
- 发现资源利用率低时，检测

<img src="https://gitee.com/ma-yunfei/picture/raw/master/20210727135514.png" alt="image-20210727135514429" style="zoom:50%;" />

缺点：

- 回滚比较困难，尤其时对于已经写入磁盘的数据，**很难回滚**

## 死锁忽略

- 不管死锁：不适用于经常不关机机的服务器，适用PC，死锁概率不高，也容易解决（重启即可）

